<!DOCTYPE html>
<html>
    <head>
        <title>Getting to 100% secure with an "https-transitional" mode.</title>
        <style>
body {
    font-family: Roboto, sans-serif;
    background: #fff;
}
            
h1, h2 {
    font-weight: 600;
}

h3 {
    font-weight: 600;
}
            
circle {
    fill-opacity: .5;
    stroke: black;
    stroke-width: 1;
}

circle.packingGroup {
    fill-opacity: .2;
    fill: none;
    stroke: none;
}

.resource {
    fill-opacity: 1;
}

text {
    font: 12px sans-serif;
}

.https {
    fill: #8f8;
}
.http {
    fill: #f88;
}
.mixed {
    fill: #ff8;
}
.transitional {
    fill: #88f;
}

.http_to_transitional {
  animation-duration: 2s;
  animation-name: http_to_transitional;
}

.http_to_https {
  animation-duration: 2s;
  animation-name: http_to_https;
}

@keyframes http_to_transitional {
  from {
    fill: #f88;
  }

  to {
    fill: #88f;
  }
}

@keyframes http_to_https {
  from {
    fill: #f88;
  }

  to {
    fill: #8f8;
  }
}

.hyperlink {
    fill: none;
}
.hyperlink.http {
  stroke-width: 1.5px;
  stroke: #fff;
}

.hyperlink.https {
    stroke-width: 1.5px;
    stroke: #000;
}

.hyperlink.underlay {
  fill: none;
  stroke: #000;
  /* setting the underlay stroke slightly less than the overlay reduces
    anti-aliasing artifacts with the dashed line but introduces some
    jaggies to solid lines.  no way to really win here.*/
  stroke-width: 1.2px;
}

        </style>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
    </head>
    <body>

        <script>
                    function drawFigure(targetName, data) {
                        var targetNode = document.getElementById(targetName);
                        var jsonData = JSON.parse(document.getElementById(data).textContent);

                        // set default sizes for resources for packing if not
                        // explicitly set: container diameter = 80, item = 15
                        jsonData.origins.forEach( function(rsc) {
                            if(!rsc.size) { rsc.size = 80; }
                            rsc.children.forEach( function(child) {
                                if(!child.size) { child.size = 15; }
                            });
                        });

                        var width = targetNode.getBoundingClientRect().width,
                            height = targetNode.getBoundingClientRect().height;

                        var svg = d3.select(targetNode).append("svg")
                        .attr("width", width)
                        .attr("height", height);

                        // Per-type markers, as they don't inherit styles.
                        svg.append("defs").selectAll("marker")
                            .data(["http", "https", "transitional"])
                            .enter().append("marker")
                            .attr("id", function(d) { return d; })
                            .attr("viewBox", "0 -5 10 10")
                            // TODO can we adjust based on target radius?
                            .attr("refX", 26)
                            .attr("refY", -1.5)
                            .attr("markerWidth", 8)
                            .attr("markerHeight", 6)
                            .attr("orient", "auto")
                            .append("path")
                            .attr("d", "M0,-5L10,0L0,5");

                        // build origin containers and layout first
                        var origin = svg.append("g").selectAll(".node")
                        .data(jsonData.origins)
                        .enter().append("g")
                        .attr("transform", function(d) {
                            return "translate("+ d.x +","+ d.y +")"
                        })
                        .attr("state", function(d) {
                            return d.state;
                        })
                        .attr("id", function(d) {
                            return targetName + "_origins_"  + d.name;
                        });

                         origin.append("circle")
                        .attr("x", 0)
                        .attr("y", 0)
                        .attr("r", function(d) { return d.size; })
                        .attr("class", function(d) { return d.state + " " + d.name; });

                        origin.append("text")
                        .style("text-anchor", "middle")
                        .text(function(d) {
                            return (d.state == "transitional" ? "http" : d.state)
                                + "://" + d.name;
                        })
                        .attr("transform", function(d) {
                            return "translate(0," + -(d.size + 5) + ")";
                        });

                        // insert hyperlinks after origins, before resources.
                        // draw two paths - an underlay and an identical path
                        // on top, which allows us to create either dashed
                        // or solid patterns with just CSS (set color of
                        // overlay and underlay the same for a solid line,
                        // or different colors for a dashed line)
                        var hyperlink_underlay = svg.append("g").selectAll("path")
                        .data(jsonData.links)
                        .enter().append("path")
                        .attr("class", "hyperlink underlay");

                        var hyperlink = svg.append("g").selectAll("path")
                        .data(jsonData.links)
                        .enter().append("path")
                        .attr("id", function(d) {
                            return targetName + "_hyperlinks_" +
                                d.fromResource + "_to_" + d.toResource;
                        })
                        .attr("stroke-dasharray", "5,5")
                        .attr("class", function(d) {
                            return "hyperlink " + (d.scheme ? d.scheme : "")
                        })
                        .attr("marker-end", function(d) {
                            return "url(#" + d.scheme + ")";
                        });
                        // we need to insert the links before the resources so
                        // they are underneath, but we don't know the layout
                        // yet of the nodes they're connecting, so do the
                        // resource layout then call hyperlinkArc() to
                        // draw the actual connections.

                        // TODO - can we do this in a more literate style
                        // using d3 selectors and third normal form for the
                        // data structure?
                        
                        // layout the resources with circle packing inside
                        // their origin.
                        var resources = jsonData.origins;
                        for(var i = 0; i < resources.length; i++) {

                            var originNode = d3.select("#" + targetName + "_origins_" + resources[i].name)
                                                .node();

                            var pack = d3.layout.pack()
                            .padding(30)
                            .size([150, 150])
                            .value(function(d) { return d.size; });

                            var g = svg.append("g")
                            .attr("transform", originNode.attributes.transform.value);

                            var pnode = g.datum(resources[i]).selectAll(".node")
                            .data(pack.nodes)
                            .enter().append("g")
                            .attr("transform", function(d) {
                                return "translate(" + (d.x - 75) + "," + (d.y - 75) + ")";
                            });

                            pnode.append("circle")
                                .attr("r", function(d) { return d.size; })
                                .attr("id", function(d) {
                                    return targetName + "_resources_" +
                                        (d.id ? d.id : "packingGroup");
                                })
                                .attr("class", function(d) {
                                    var depthClass = d.depth > 0 ? "resource" : "packingGroup";
                                    var stateClass = d.depth == 0 ? "" :
                                        (d.state ? d.state : originNode.attributes.state.value);
                                    var originClass = d.depth == 0 ? "" : resources[i].name;
                                    return depthClass + " " + stateClass + " " + originClass;
                                });

                            pnode.filter(function(d) { return d.depth > 0; }).append("text")
                                .attr("dy", ".3em")
                                .style("text-anchor", "middle")
                                .text(function(d) { return d.name.substring(0, d.r / 3); })
                        }

                        svg.selectAll(".hyperlink").attr("d", hyperlinkArc);

                        function hyperlinkArc(d) {
                            var target = d3.select("#" + targetName + "_resources_" + d.toResource)
                                        .node();
                            var source = d3.select("#" + targetName + "_resources_" + d.fromResource)
                                        .node();

                            // This is the magic to find our target node position
                            // and still draw links at the right render depth.
                            // (not as childern inheriting the <g> transform,
                            // which would put them on top)  Get the bounding
                            // rectangle and the coordinate transformation matrix
                            // and apply these to find the "true" center of each
                            // resource circle.
                            var offset = svg.node().getBoundingClientRect();
                            var tMatrix = target.getScreenCTM();
                            var sMatrix = source.getScreenCTM();
                            
                            var sCoords = getXformedCoords(
                                source.cx.baseVal.value, source.cy.baseVal.value, offset, sMatrix);
                            var tCoords = getXformedCoords(
                                target.cx.baseVal.value, target.cy.baseVal.value, offset, tMatrix);

                            var dx = tCoords.x - sCoords.x,
                                dy = tCoords.y - sCoords.y,
                                dr = Math.sqrt(dx * dx + dy * dy);
                            return "M" + sCoords.x + "," + sCoords.y +
                                "A" + dr + "," + dr + " 0 0,1 " +
                                tCoords.x + "," + tCoords.y;
                        };
                        
                        function getXformedCoords(x, y, offset, matrix) {
                            return {
                                x: (matrix.a * x) + (matrix.c * y) +
                                    matrix.e - offset.left,
                                y: (matrix.b * x) + (matrix.d * y) +
                                    matrix.f - offset.top
                            }
                        }
                    }
        </script>

        <h1>
            Why isn't HTTPS everywhere yet?
        </h1>
        <p>
            Encryption.  We all like it and want more of it.  Why isn't HTTPS
            everywhere yet?
        </p>
        <h2>
            Is it certificates?
        </h2>
        <p>
            The first and most commonly cited barrier to HTTPS everywhere is
            the cost (both time and effort) of
            obtaining, configuring, presenting and maintaining a valid
            certificate.  You must find a certificate authority, prove your
            identity, pay for a certificate, set it up on your server (you
            probably need to have a dedicated IPv4 address to support old 
            clients that don't
            do Server Name Indication) and renew it before it expires.
        </p>
        <p>
            A lot of the proposals for "opportunistic" encryption are targeted
            at this level of the problem, and amount to: "The NSA is
            recording all of our traffic, so why don't we just encrypt even if
            we don't have a certificate?"
        </p>
        <p>
            I appreciate the spirit of this solution, but I have come
            to believe it is actually targeting the wrong obstacles. First, this
            flavor of OE solves very few problems because you can never rely on
            it, even when it appears to succeed.  For users that care, it offers
            little comfort, and for site operators who want to get to reliable
            guarantees, it offers no easier path forward. Second, I don't think
            the certificate problem is actually the biggest challenge blocking
            HTTPS everywhere anymore.
        </p>
        <p>
            The fine folks over at
            <a href="https://letsencrypt.org/">Let's Encrypt</a>
            already realized that the
            certficate problem is mostly amenable to automation, and that
            automating the issuance, installation, configuration, deployment
            and renewal of certificates and TLS on a relatively few of the major
            servers+platforms can cover a substantial supermajority of the
            Internet.  This is amazing work, and while there is still much of
            that race left to be run, I think we can optimistcally call it a
            solved problem.
        </p>
        <p>
            The SNI + IPv4 issue (mulitple hosts can't share the same IPv4
            address for clients that don't support Server Name Indication
            without getting a certificate with all of their names in it) I am
            confident will naturally resolve itself as those old platforms
            tail off and IPv6 ramps up.
        </p>
        
        <h2>
            Now we have a certificate, we can turn on HTTPS, right?
        </h2>
        <p>
            Well, maybe.  But probably not.  If all of the HTML resources you
            serve have subresources (images, scripts, etc.) loaded from the
            same host AND you used only relative urls (e.g. "/foo.jpg" instead
            of "http://example.com/foo.jpg") then you are good to go!  Otherwise
            things are probably broken for you at your "https://" URLs.
        </p>
        <p>
            <i>Wait, what?  HTTPS is supposed to be good. Why is everything
            broken?</i>
        </p>
        <p>
            It's broken because you almost certainly have
            <a href="http://w3.org/TR/mixed-content">Mixed Content</a>
            in your pages.
        </p>
        <h2>What is Mixed Content and why should I care?</h2>
        <p>
            Mixed Content is the term that has arisen out of practice
            for the situation when a document loaded over https includes content
            loaded over http.
        </p>

        <p>
            Consider the following set of resources, where you are the operator
            of "OriginA".  Green circles represent resources avialable over
            both https and http schemes, red circles represent resources only
            available over http schemes.  Dashed lines represent subresource
            includes made with an http scheme.  Solid lines represent subresource
            includes made with an https scheme.  Assume that all links are absolute,
            not relative.
        </p>
        <script id="figure2data" type="application/json">
        {
            "origins" : [
                {
                    "name": "OriginA",
                    "x": 300,
                    "y": "100",
                    "state": "http",
                    
                    "children" :  [
                        {"name" : "HTML", "id" : "1", "size" : 18},
                        {"name" : "JS",   "id" : "2" },
                        {"name" : "JPG",  "id" : "3" }
                    ]
                    
                },
                {
                    "name": "OriginB",
                    "x": 200,
                    "y": "300",
                    "state": "http",
                    "children" :  [
                        {"name" : "HTML", "id" : "4", "size" : 18},
                        {"name" : "JSON", "id" : "5"},
                        {"name" : "JS",   "id" : "6"}
                    ]
                },
                {
                    "name": "OriginC",
                    "x": 100,
                    "y": "100",
                    "state": "https",
                    
                    "children" :  [
                        {"name" : "JS", "id" : "10"}
                    ]
                }
            ],
            "links": [
                {"fromResource": "1", "toResource":"2", "scheme":"http"},
                {"fromResource": "1", "toResource":"3", "scheme":"http"},
                {"fromResource": "1", "toResource":"6", "scheme":"http"},
                {"fromResource": "1", "toResource":"10", "scheme":"http"}
            ]
        }
        </script>
        
        <div id="figure2" style="height: 425px"></div>
        <script>drawFigure("figure2", "figure2data");</script>

        <p>
            Now let's say you acquire a certificate and turn on https for OriginA.
            What does the resource graph look like now?
        </p>
        
        <script id="figure3data" type="application/json">
                {
            "origins" : [
                {
                    "name": "OriginA",
                    "x": 300,
                    "y": "100",
                    "state": "https",
                    
                    "children" :  [
                        {"name" : "HTML", "id" : "1", "size" : 18, "state" : "mixed"},
                        {"name" : "JS",   "id" : "2" },
                        {"name" : "JPG",  "id" : "3" }
                    ]
                    
                },
                {
                    "name": "OriginB",
                    "x": 200,
                    "y": "300",
                    "state": "http",
                    "children" :  [
                        {"name" : "HTML", "id" : "4", "size" : 18},
                        {"name" : "JSON", "id" : "5"},
                        {"name" : "JS",   "id" : "6"}
                    ]
                },
                {
                    "name": "OriginC",
                    "x": 100,
                    "y": "100",
                    "state": "https",
                    
                    "children" :  [
                        {"name" : "JS", "id" : "10"}
                    ]
                }
            ],
            "links": [
                {"fromResource": "1", "toResource":"2", "scheme":"http"},
                {"fromResource": "1", "toResource":"3", "scheme":"http"},
                {"fromResource": "1", "toResource":"6", "scheme":"http"},
                {"fromResource": "1", "toResource":"10", "scheme":"http"}
            ]
        }
        </script>
        
        <div id="figure3" style="height: 400px"></div>
        <script>drawFigure("figure3", "figure3data");</script>
        
        <p>
            If you haven't updated absolute links in the HTML document, it will
            still be attempting to load all of its resources with an http scheme.
            Most web browsers block such loads or give negative UI feedback when
            they occur, and they have been getting more and more strict about it
            over time.  The HTML resource at OriginA will be broken because
            attempts to load the three JS resources it depends on will be blocked,
            and it will be marked with a mixed content warning for the JPG, even
            if we didn't have the JS resources.
        </p>
        
        <h3>
            Why do browsers block mixed content loads?
            Why can't I as a site operator make that decision?
        </h3>
        <p>
            In most of the Web security model, Origins (the scheme+host+port
            tuple of a URL) are authoritative for their own information.  A
            document loaded from HTTPS can navigate the user to an insecure
            destination with sensitive data in the GET string or fragment,
            it can POST or postMessage() to insecure schemes or origins, and
            an https resource can receive GET, POST or onMessage() from documents
            loaded over http. So, if we don't have formal information flow controls
            on the Web, why is Mixed Content Blocking a thing? If I can POST,
            why can't I XHR?
        </p>
        <p>
            It turns out there is  one formal security property that
            browsers try to enforce on documents.  That is a property
            first formulated as <i>"Tranquility"</i> by
            <a href="https://en.wikipedia.org/wiki/Bell%E2%80%93LaPadula_model">
            Bell and LaPadula in their 1973 integrity model.</a>
            In simple terms, the tranquility enforced by web browsers is that
            a secure docment will not become insecure while you are interacting
            with it.
        </p>
        <p>
            Among all the complexity and
            potential pitfalls of Web security, browsers have come to
            the conclusion that there is only one semi-reliable and usable security
            indicator: the URL bar and HTTPS lock.  If you type "https://" into
            the address bar, or at any point check to see if there is a lock
            icon for the document you are interacting with, the browser has made
            you a promise that the content is protected from threats involving a
            hostile network. (or alternately, the browser is conveying a promise
            from the site operator which it is unwilling to let it reneg on)
        </p>
        <p>
            If your https
            document were to load a script, preform a fetch or even load an image
            over http, that promise would be broken.  How broken and what the
            exact consequences would be
            might vary widely, but the browser isn't in a position to know, and
            doesn't want to impose the burden of that subtlety on the user, so
            they simply block.  This is done not only to protect users who
            wouldn't otherwise be aware that, e.g., a webmail application which
            shows https in the address bar but includes script over http isn't
            safe to use in a coffeeshop in the
            hacker part of town, but also to highlight the same issue to content
            authors who might themselves otherwise miss this subtle point.
        </p>
        <p>
            This is a good thing for users, but it puts site operators newly in
            posession of a certificate in a bit of difficulty when it comes to
            turning on https.  All of their HTML resources which reference
            insecure content are going to break outright or alarm some population
            of users, either by showing a warning or simply not showing the lock
            they expect for https.  <b>This dependency problem, I assert, is the real
            cost barrier we must surmount in order to move the rest of the Web
            to 100% HTTPS.</b>
        </p>
        <h2>
            Fixing Mixed Content
        </h2>
        <p>
            As soon as you have to fix Mixed Content, the cost
            of migrating to HTTPS starts to get real.  Much more so than any
            kind of server configuration or acquisition of a certificate, removing
            mixed content is expensive and not always well-suited to automation because it often
            requires understanding all the possible content served by a host,
            modifying it (conditionally) and (possibly most expensively) testing
            to verify that everything works.
        </p>
        <p>
            For a complex site, it's not as simple as running s/http/https/g
            across all of your resources, on disk or with a mod_rewrite rule.
            You might encounter http-schemed resources in many places: static
            content, dynamic content generated on the server, on the client,
            stored in databases (on the server or client), retrieved from other
            third party redirects, etc.
        </p>
        <p>
            A new specification under development, (and already supported by
            Chrome and Firefox)
            <a href="http://www.w3.org/TR/upgrade-insecure-requests/">Upgrade
            Insecure Requests</a>, aims to ease this burden by automatically
            upgrading http subresource fetches to https, along with same-origin
            navigations.
        </p>
        
        <script id="figure4data" type="application/json">
        {
            "origins" : [
                {
                    "name": "OriginA",
                    "x": 300,
                    "y": "100",
                    "state": "https",
                    
                    "children" :  [
                        {"name" : "HTML", "id" : "1", "size" : 18, "state": "mixed"},
                        {"name" : "JS",   "id" : "2" },
                        {"name" : "JPG",  "id" : "3" },
                        {"name" : "HTML", "id" : "11", "size" : 18, "state" : "mixed"}
                    ]
                },
                {"name": "OriginB", "x": 200, "y": "300", "state": "http",
                    "children" :  [
                        {"name" : "HTML", "id" : "4", "size" : 18},
                        {"name" : "JSON", "id" : "5"},
                        {"name" : "JS",   "id" : "6"}
                    ]
                },
                {"name": "OriginC", "x": 100, "y": "100", "state": "https",
                    "children" :  [
                        {"name" : "JS", "id" : "10"}
                    ]
                }
            ],
            "links": [
                {"fromResource": "1", "toResource":"2", "scheme":"http"},
                {"fromResource": "1", "toResource":"3", "scheme":"http"},
                {"fromResource": "1", "toResource":"6", "scheme":"http"},
                {"fromResource": "1", "toResource":"10", "scheme":"http"},
                {"fromResource": "11", "toResource":"2", "scheme":"http"},
                {"fromResource": "11", "toResource":"10", "scheme":"http"}
            ]
        }
        </script>

        <script id="figure5data" type="application/json">
        {
            "origins" : [
                {
                    "name": "OriginA",
                    "x": 300,
                    "y": "100",
                    "state": "https",
                    
                    "children" :  [
                        {"name" : "HTML", "id" : "1", "size" : 18, "state": "mixed"},
                        {"name" : "JS",   "id" : "2" },
                        {"name" : "JPG",  "id" : "3" },
                        {"name" : "HTML", "id" : "11", "size" : 18}
                    ]
                },
                {"name": "OriginB", "x": 200, "y": "300", "state": "http",
                    "children" :  [
                        {"name" : "HTML", "id" : "4", "size" : 18},
                        {"name" : "JSON", "id" : "5"},
                        {"name" : "JS",   "id" : "6"}
                    ]
                },
                {"name": "OriginC", "x": 100, "y": "100", "state": "https", 
                    "children" :  [
                        {"name" : "JS", "id" : "10"}
                    ]
                }
            ],
            "links": [
                {"fromResource": "1", "toResource":"2", "scheme":"https"},
                {"fromResource": "1", "toResource":"3", "scheme":"https"},
                {"fromResource": "1", "toResource":"6", "scheme":"https"},
                {"fromResource": "1", "toResource":"10", "scheme":"https"},
                {"fromResource": "11", "toResource":"2", "scheme":"https"},
                {"fromResource": "11", "toResource":"10", "scheme":"https"}
            ]
        }
        </script>
        
        <h3>Before</h3>
        <div id="figure4" style="height: 400px; width: 500px"></div>
        
        <h3>After Upgrade-Insecure-Requests</h3>
        <div id="figure5" style="height: 400px; width: 500px"></div>
        <script>drawFigure("figure4", "figure4data");</script>
        <script>drawFigure("figure5", "figure5data");</script>
        
        
        <p>
            Upgrade-Insecure-Resources has helped OriginA here.
            One of its HTML resources is now
            free of mixed content because all of the link schemes have been transparently
            upgraded and all its remote dependencies are available over https.
            However, we still have one broken resource because the JS dependency
            from OriginB is still not available over https.
            This illustrates why, until all of their dependencies have upgraded
            to https, many sites are reluctant to offer any of their own content
            over https, to avoid presenting users with broken experiences and
            worrying error messages.
        </p>
        <p>
            This leads to the unfortunate circumstance that the least
            accountable actors at the end of long dependency chains can hold
            back progress for everyone upstream. Cyclical dependencies
            (as certainly exist in the large scale structure of the web) can
            create deadlocks which totally prevent upgrades without coordination.
        </p>
        <h3>None of these sites can turn on https</h3>
        <script id="figure6data" type="application/json">
        {
            "origins" : [
                {"name": "OriginA", "x": 300, "y": "300", "state": "http",
                    "children" :  [
                        {"name" : "HTML", "id" : "1", "size" : 18},
                        {"name" : "JS",   "id" : "2" }
                    ]},
                {"name": "OriginB", "x": 200, "y": "100", "state": "http",
                    "children" :  [
                        {"name" : "HTML", "id" : "3", "size" : 18},
                        {"name" : " JS",   "id" : "4" }
                    ]},
                {"name": "OriginC", "x": 100, "y": "300", "state": "http",
                     "children" :  [
                        {"name" : "HTML", "id" : "5", "size" : 18},
                        {"name" : "JS",   "id" : "6" }
                    ]}
            ],
            "links": [
                {"fromResource": "1", "toResource":"4", "scheme":"http"},
                {"fromResource": "3", "toResource":"6", "scheme":"http"},
                {"fromResource": "5", "toResource":"2", "scheme":"http"}
            ]
        }
        </script>
        
        <div id="figure6" style="height: 400px"></div>
        <script>drawFigure("figure6", "figure6data");</script>
        <p>
            To make matters even worse, it is not trivial to even determine if
            your dependencies are ready!  Once you go HTTPS, errors will
            just start happening for your users, and you have no obvious way to
            catch them in advance. (A "<tt>default-src https:</tt>" Content Security
            Policy directive can tell you when things actually broke, but you
            can't easily compose it with an optimistic upgrade to test without
            actual breakage.)
        </p>
        <p>For modern applications with complex client-side logic,
            serving large user bases, and using things like Real-Time-Bidding
            advertising networks, the difficulty of creating a reasonable simulation of
            traffic and user experience for test purposes is quite real. Just
            the set of domain names you reference may be emergent runtime
            behavior with substantial variance over time.
        </p>
        <h2>
            Breaking the deadlock
        </h2>
        <p>
            What we lack is an intermediate state between http and https.
            Ideally, such a state would have the following properties:
            <ol>
                <li>
                    Allow secure origins which depend on resources you serve to
                    retrieve them in way which does not violate their secure
                    tranquility.
                </li>
                <li>
                    Do not force resources to make premature or unverified
                    guarantees of secure tranquility / lack of mixed content.
                </li>
                <li>
                    Be extremely low-cost and low-risk to deploy; ideally
                    requiring zero content-level changes, only server
                    configuration updates. (including possibly adding one or
                    more http headers)
                </li>
                <li>
                    Allow detection of dependencies which would violate secure
                    tranquility / produce mixed content errors without
                    negatively impacting the user experience.
                </li>
            </ol>
        </p>
            <script id="figure7data" type="application/json">
        {
            "origins" : [
                {"name": "OriginA", "x": 300, "y": "300", "state": "http",
                    "children" :  [
                        {"name" : "HTML", "id" : "1", "size" : 18},
                        {"name" : "JS",   "id" : "2" }
                    ]},
                {"name": "OriginB", "x": 200, "y": "100", "state": "http",
                    "children" :  [
                        {"name" : "HTML", "id" : "3", "size" : 18},
                        {"name" : " JS",   "id" : "4" }
                    ]},
                {"name": "OriginC", "x": 100, "y": "300", "state": "http",
                     "children" :  [
                        {"name" : "HTML", "id" : "5", "size" : 18},
                        {"name" : "JS",   "id" : "6" }
                    ]},
                {"name": "OriginD", "x": 400, "y": "100", "state": "http",
                     "children" :  [
                        {"name" : "JS",   "id" : "7" }
                    ]}
            ],
            "links": [
                {"fromResource": "1", "toResource":"4", "scheme":"http"},
                {"fromResource": "3", "toResource":"6", "scheme":"http"},
                {"fromResource": "3", "toResource":"7", "scheme":"http"},
                {"fromResource": "5", "toResource":"2", "scheme":"http"}
            ]
        }
        </script>
        
        <h3>Click on the figure below to see how introducing an intermediate
            state (indicated with blue) with these properties can break an upgrade deadlock cycle.</h3>

        <div id="figure7" style="height: 400px" onclick="animateFigure7()"></div>
        <script>
            function h2h2t(d) {
                return d.replace(/\bhttp\b/, "http_to_transitional");
            }
            
            function h2t2t(d) {
                return d.replace(/\bhttp_to_transitional\b/, "transitional ");
            }
            
            function h2h2s(d) {
                return d.replace(/http /, "http_to_https ");
            }
            
            function h2s2s(d) {
                return d.replace(/http_to_https /, "https ");
            }
            
            function h2s(d) {
                return d.replace(/http/, "https");
            }
            
            function animateFigure7() {
            document.getElementById("figure7_origins_OriginB")
            .firstChild
            .addEventListener("animationend", step1, false);
            
            // step 0
            document.getElementById("figure7_origins_OriginB")
                .lastChild
                .textContent = "http[s]://OriginB";
                
            d3.selectAll("#figure7 circle.OriginB")
                .attr("class", function(d) { return h2h2t(d3.select(this).attr("class")) });
            
            function step1() {
                d3.selectAll("#figure7 circle.OriginB")
                .attr("class", function(d) { return h2t2t(d3.select(this).attr("class")) });
                
                document.getElementById("figure7_origins_OriginA")
                .firstChild
                .addEventListener("animationend", step2, false);
                
                document.getElementById("figure7_origins_OriginA")
                .lastChild
                .textContent = "https://OriginA";
                
                d3.selectAll("#figure7 circle.OriginA")
                .attr("class", function(d) { return h2h2s(d3.select(this).attr("class")) });
            }
            
            function step2() {
                d3.selectAll("#figure7 circle.OriginA")
                .attr("class", function(d) { return h2s2s(d3.select(this).attr("class")) });
                
                document.getElementById("figure7_origins_OriginC")
                .firstChild
                .addEventListener("animationend", step3, false);
                
                document.getElementById("figure7_origins_OriginC")
                .lastChild
                .textContent = "https://OriginC";
                
                d3.selectAll("#figure7 circle.OriginC")
                .attr("class", function(d) { return h2h2s(d3.select(this).attr("class")) });
                
                d3.select("#figure7_hyperlinks_5_to_2")
                .attr("class", function(d) { return h2s(d3.select(this).attr("class")) });
            }
            
            function step3() {
                d3.selectAll("#figure7 circle.OriginC")
                .attr("class", function(d) { return h2s2s(d3.select(this).attr("class")) });
                // TODO reset figure?
            }
                
            }
            
            drawFigure("figure7", "figure7data");

        </script>

        <p>
            First, OriginB turns on "https-transitional" mode.  This means that is resources are
            still not available at URLs with an https scheme, but are optimistically available
            over TLS with the full guarantees, including a valid certificate.  This is essentially
            zero-cost for OriginB because it makes no new guarantees to users or browsers about
            the security state or tranquility of its own resources.
        </p>
        <p>
            Now that OriginB's resources are available via "https-transitional", OriginA turns on
            https.  It has an HTML file with an http dependency on the JS file at OriginB.  A
            browser that knows about "https-transitional" can try to initiate a TLS connection
            to OriginB and ask for the resource with its original http scheme.  If this
            optimistic upgrade fails, it would be treated as insecure and trigger mixed content
            blocking, so we haven't reduced the guarantees to users of OriginA.  If it succeeds,
            all of the standard guarantees required for OriginA to be secure and tranquil are met,
            and no mixed content warning or blocking would be triggered, even though the reference
            to the JS file at OriginB still used the http scheme.
        </p>
        <p>
            Now that OriginA has upgraded, OriginC can upgrade, too.  OriginB still has a dependency
            to OriginD which is only  http, so it can't yet go to https, but by turning on
            transitional mode, it has unblocked upgrades for A and B, without creating any negative
            user experiences for its own users due to mixed content from D.  Without the transitional
            state, none of these sites could have upgraded.
        </p>
    
        <p>
            The interesting bit here is the link from OriginA's HTML resource to OriginB's JS resource.
            It needs to satisfy all the properties of TLS - but whether it remains an http scheme that
            is transparently upgraded during the fetch from OriginB, or whether it is upgraded at OriginA
            before a fetch is even attempted depends on how this transitional state might be implemented.
        </p>
    
        <h2>
            How could we introduce this state?
        </h2>
        <p>
            A first approxmiation, just to break resource dependency deadlocks without introducing documents
            with mixed content into the world, would be to enable https
            with a server filter that returns a 404 whenever it would otherwise return a Content-Type of text/html.
            In fact, it's probably a surprisingly good approximation, modulo some edge cases involving
            CORS. Of the four properties we are interested in, this even gets us a pretty good take on three of them.
        <p>
            What is missing is the 4th property - the ability to detect the state of your own dependencies so
            you can know when it's OK to flip the "real https" switch.  What if browsers could do
            Content-Security-Policy-Report-Only with "upgrade-insecure-requests" for http documents?
            <ol>
                <li>attempt to upgrade</li>
                <li>if upgrade fails</li>
                <ol>
                    <li>fall back to http fetch</li>
                    <li>fire a report</li>
                </ol>
            </ol>
        </p>
        <p>
            Is it possible we don't need anything more than that?  Basically this
            configuration, with Upgrade-Insecure-Requests
            implied for A, B, and C?
        </p>
            <script id="figure8data" type="application/json">
        {
            "origins" : [
                {"name": "OriginA", "x": 300, "y": "300", "state": "https",
                    "children" :  [
                        {"name" : "HTML", "id" : "1", "size" : 18},
                        {"name" : "JS",   "id" : "2" }
                    ]},
                {"name": "OriginB", "x": 200, "y": "100", "state": "https",
                    "children" :  [
                        {"name" : "HTML", "id" : "3", "size" : 18, "state" : "http"},
                        {"name" : " JS",   "id" : "4", "state" : "https"}
                    ]},
                {"name": "OriginC", "x": 100, "y": "300", "state": "https",
                     "children" :  [
                        {"name" : "HTML", "id" : "5", "size" : 18},
                        {"name" : "JS",   "id" : "6" }
                    ]},
                {"name": "OriginD", "x": 400, "y": "100", "state": "http",
                     "children" :  [
                        {"name" : "JS",   "id" : "7" }
                    ]}
            ],
            "links": [
                {"fromResource": "1", "toResource":"4", "scheme":"https"},
                {"fromResource": "3", "toResource":"6", "scheme":"http"},
                {"fromResource": "3", "toResource":"7", "scheme":"http"},
                {"fromResource": "5", "toResource":"2", "scheme":"https"}
            ]
        }
        </script>
        
        <div id="figure8" style="height: 400px"></div>
        <script>drawFigure("figure8", "figure8data");</script>

        <h3>Enter the &lt;iframe&gt;</h3>
        <p>
            Unfortunately, no, just filtering HTML resources from being offered over
            standard https isn't enough; it fails with HTML to HTML dependencies from
            iframes.  This is actually quite common for advertising.
        </p>

        <script id="figure9data" type="application/json">
        {
            "origins" : [
                {"name": "OriginA", "x": 100, "y": "100", "state": "https",
                    "children" :  [
                        {"name" : "HTML", "id" : "1", "size" : 18, "state": "mixed"},
                        {"name" : "JS",   "id" : "2" }
                    ]},
                {"name": "OriginB", "x": 300, "y": "100", "state": "https",
                    "children" :  [
                        {"name" : "HTML", "id" : "3", "size" : 18, "state" : "http"},
                        {"name" : " JPG",   "id" : "4", "state" : "https"},
                        {"name" : " JS",   "id" : "5", "state" : "https"}
                    ]}
            ],
            "links": [
                {"fromResource": "1", "toResource":"4", "scheme":"https"},
                {"fromResource": "1", "toResource":"3", "scheme":"http"},
                {"fromResource": "1", "toResource":"2", "scheme":"https"},
                {"fromResource": "1", "toResource":"5", "scheme":"https"}
            ]
        }
        </script>
        
        <div id="figure9" style="height: 200px"></div>
        <script>drawFigure("figure9", "figure9data");</script>
        <p>
            What we need to unblock a dependency tree for iframes is also
            <i>optimistic secure tranquility</i>.  That is, we must be able to attempt
            to optimistically load an HTML resource with a TLS upgrade, and
            enforce tranquility on it, <i>but only from a secure, framed context</i>.
            The key to why this is OK is that a non-upgraded document would already be broken
            when loaded in this way, so we aren't introducing any new breakage
            or mixed content experiences for users of OriginB.
        </p>
        <h3><tt>https-transitional</tt> with ALPN and HTTP Alt-Svc</h3>
        <p>
            <a href="https://tools.ietf.org/html/rfc7301">
            ALPN</a> allows a client interacting with a server over TLS to
            indicate a different application layer protocol it wishes to use.
        </p>
        <p>
            Let's imagine a new ALPN protocol type: "https-transitional".  A
            server which sees a client request for that understands it as:
            "connect me to the resources and configuration served over http,
            but over TLS, not the https site, please".
            (The state of firewalls and other middleboxes effectively prevents
            the the introduction of a new port with any expectation of wide
            compatbility.)  As described by the HTTP Alt-Svc draft, a full and
            successful TLS connection must be completed, and the server must
            present a certificate which matches the original http hostname.
            Unlike the ALt-Svc mechanism, resources fetched as transitional
            will behave slightly differently.
        </p>
        <p>
            A resource fetched over "https-transitional" will
            have the following properties in the user agent:
            <ul>
                <li>
                    A resource fetched over "https-transitional" should not be
                    blocked as mixed content if the responsible document's
                    settings object restricts mixed content.
                </li>
                <li>
                    The settings object for a document fetched over
                    "https-transitional" should not restrict mixed content.
                </li>
                <li><i>Unless</i> any ancestor frames of the document
                    restrict mixed content, in which case it must
                    restrict mixed content, and <tt>upgrade-insecure-requests</tt>
                    is automatically impled.</li>
            </ul>
        </p>
        <p>
            Upgrade-Insecure-Requests would be modified in the following way:
            <ul>
                <li>
                    When encountering a subresoruce with an http scheme to be
                    upgraded, connect to the https endpoint of the server at
                    the indicated Origin, and add the new "https-transitional"
                    ALPN protocol, as preferred, in addition to the standard
                    http/spdy/h2 protocol that would ordinarily be used.
                </li>
                <li>
                    If a server understands the "https-transitional" ALPN
                    negotiation, respond on that protocol and deliver the
                    http resource over TLS.
                </li>
                <li>
                    A server which does not understand the "https-transitional"
                    protocol will respond with the resource from the https site,
                    if available.
                </li>
            </ul>
        </p>
        <p>
            Mixed Content blocking would also be modified.  User agents do not
            currently automatically attempt to upgrade http -> https in contexts
            where mixed content is blocked because there is no explicit
            guarantee that the resources at both schemes are semantically
            equivalent.  The "https-transitional" scheme <i>does</i> explicitly
            make the equivalency guarantee, so a user
            agent can always automatically attempt to upgrade any request
            which would be blocked as insecure mixed content to "https-transitional"
            without any hint from the server.
        </p>
        <p>
            Servers could also advertise the availability of transitional mode
            with the <a href="https://tools.ietf.org/html/draft-ietf-httpbis-alt-svc">
            HTTP Alt-Svc</a> header.  If a user agent has seen an Alt-Svc
            advertisement for an Origin that is still fresh, it can always
            make the upgrade, even for navigational requests, giving the
            benefits of opportunistic encryption against passive adversaries.
        </p>
        <p>
            When a document has been loaded in transitional mode, the user agent
            should attempt to upgrade all resources which would have been blocked
            as mixed-content, as if <tt>upgrade-insecure-resources</tt> had been
            set, but must silently retry over http if the upgrade fails.  It
            must report an error on the console in such cases and SHOULD provide
            a means for sites to request reports similar to (or re-using) the
            Content Security Policy mechanism.  This will allow operators to
            understand, from genuine user traffic, whether all of their
            dependencies are upgradable, as part of a transition to full https.
        </p>
            <script id="figure10data" type="application/json">
         {
            "origins" : [
                {"name": "OriginA", "x": 100, "y": "100", "state": "https",
                    "children" :  [
                        {"name" : "HTML", "id" : "1", "size" : 18},
                        {"name" : "HTML", "id" : "2", "size" : 18}
                    ]
                },
                {"name": "OriginB", "x": 300, "y": "100", "state": "transitional",
                    "children" :  [
                        {"name" : " HTML",   "id" : "7", "size" : 18},
                        {"name" : "HTML", "id" : "3", "size" : 18, "state" : "mixed"},
                        {"name" : " HTML",   "id" : "4", "size" : 18}
                    ]
                },
                {"name": "OriginC", "x": 500, "y": "100", "state": "transitional",
                    "children" :  [
                        {"name" : " JS",   "id" : "5"}
                    ]
                },
                {"name": "OriginD", "x": 450, "y": "300", "state": "http",
                    "children" :  [
                        {"name" : " JS",   "id" : "6"}
                    ]
                }
            ],
            "links": [
                {"fromResource": "1", "toResource":"4", "scheme":"http"},
                {"fromResource": "2", "toResource":"3", "scheme":"http"},
                {"fromResource": "3", "toResource":"6", "scheme":"http"},
                {"fromResource": "4", "toResource":"5", "scheme":"http"},
                {"fromResource": "7", "toResource":"6", "scheme":"http"}
            ]
        }
        </script>
        
        <div id="figure10" style="height: 400px"></div>
        <script>drawFigure("figure10", "figure10data");
                document.getElementById("figure10_origins_OriginB")
                .lastChild
                .textContent = "http[s]://OriginB";
                document.getElementById("figure10_origins_OriginC")
                .lastChild
                .textContent = "http[s]://OriginC";
            
        </script>
        <p>
            The above figure represents the implications of these rules.
            Resources loaded from OriginA which iframe resources from
            OriginB will never have mixed content warnings because OriginB
            supports transitional mode.  However, if resources from OriginB
            are loaded in iframes from documents that block mixed content,
            and depend on resources which cannot be upgraded, (such as the
            JS resource on OriginD) those fetches will silently be blocked to
            maintain the tranquility of the ancestor resources.  This partial
            breakage is still preferrable to the current state where the
            initial load from OriginA would have been completely blocked.
            A resource loaded as a direct navigation from OriginB which depends
            on the same non-upgradable resource at OriginD would not have see
            the load blocked becuase it does not inherit a tranquility contract
            from a frame ancestor.
        </p>
        <h3>Performance Impacts</h3>
        <p>
            For https resources, this proposal shouldn't introduce any new
            latency compared to using Upgrade-Insecure-Requests.  The ALPN
            negotiation makes it totally transparent.  Browsers will be attempting
            TLS first, anyway, and it won't require any additional round trips
            to determine if https-transitional is supported.
        </p>
            The only place where there may be a performance impact is when
            a navigational request is upgraded due to the presence of an
            Alt-Svc header.  Because the user agent will attempt to recursively
            upgrade all subresources of an upgraded document, which may not all
            be available upgraded or over https, this has the possibility of
            introducing significant new latency. User agents might reduce this
            by remembering the fact that TLS was unavailable for a given origin
            for some period of time, or they might attempt upgraded and non-upgraded
            fetches in parallel to be able to instantly substitute the http
            version on an aggressive timeout for secure connection establishment.
            This latter approach is bad for privacy in the presence of passive
            attackers.  Some experimentation is probably necessary here to arrive
            at the best strategy.  Peformance costs will be higher when transitional mode is
            new, and will consistently decline as it becomes more widely available.
        <p>
            
        </p>
        <h2>Locking down</h2>
        <p>
            At some point, sites will still want to abandon plaintext http. A
            load from an https context will never fail down to plaintext or
            an unauthenticated connection, but optimistic upgrades are not,
            by themselves, enough to stop an active network attacker from
            forcing a downgrade back to an unecrypted connection for navigations
            or top-of-window resources loaded transitionally.  During
            the transitional period, it's an explicit goal to never break
            if the upgrade can't succeed.  How do we get
            from transitional to finally secure, especially if the existence
            of transitional is a means to avoid sites having to change the
            scheme of every http link out there?  Related to this, we also
            eventually want to be able to enforce tranquility on upgraded
            resources to stop those same attackers.
        </p>
        <p>
            We can start with some design patterns from
            <a href="http://www.rfc-editor.org/rfc/rfc6797.txt">HTTP
            Strict Transport Security</a>, which was invented to solve this
            problem for HTTPS sites that wanted to fully deprecate HTTP.
            Security, as well as the Alt-Svc header mentioned earlier.
        </p>
        <p>
            The first thing a site could do is set the freshness of its Alt-Svc
            advertisement to "infinite".  This would be a signal to user agents
            which understand it to never attempt a plaintext connection to that
            Origin again - only use https-transitional and https, forever.
            User agents might, as they do today, allow sites to opt-in to a
            preload of this setting.  After doing this, a service could continue
            to offer service over plaintext for legacy clients, or it could
            turn it off if it determines that traffic is acceptably low.
        </p>
        <p>
            The next thing is that content served with transitional mode needs
            a way to opt-in to tranquility.  This is also probably best handled
            by an HTTP header.  Setting the "tranquil" bit would imply at least
            that the document's setting object should restrict mixed content.
            It might even allow such a resource to be eligible to be same-origin
            with https content, though that requires additional analysis, and
            probably would be a different flag, so sites can make
            appropriate transition of cookies, local storage and other Origin
            scoped state on the client.  A tranquil resource might also be
            eligible to get the "lock" or whatever other secure UI treatement
            is applied to https.
        </p>
        <p>
            Eventually, if penetration of transitional mode is sufficient,
            user agents could start dropping support for http.  Perhaps first
            as a user preference flag, then with a compatibility list enabling
            a few laggard sites to still use plaintext, then with a big,
            interstitial warning.  As flag days go, this would be much less
            painful than the current possibilities, because the process of
            readying your site for the transition could be almost entirely
            automated, with little or no risk of breakage.  Many sites would
            probably stay at the transitional state indefinitely, but users would
            still be getting all the benefits they expect from TLS today.
        </p>
    </body>
</html>

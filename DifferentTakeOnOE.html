<!DOCTYPE html>
<html>
    <head>
        <style>
body {
    font-family: Roboto, sans-serif;
    background: #fff;
}
            
h1, h2 {
    font-weight: 600;
}

h3 {
    font-weight: 600;
}
            
circle {
    fill-opacity: .5;
    stroke: black;
    stroke-width: 1;
}

circle.packingGroup {
    fill-opacity: .2;
    fill: none;
    stroke: none;
}

.resource {
    fill-opacity: 1;
}

text {
    font: 12px sans-serif;
}

.https {
    fill: #8f8;
}
.http {
    fill: #f88;
}
.mixed {
    fill: #ff8;
}
.transitional {
    fill: #88f;
}

.http_to_transitional {
  animation-duration: 2s;
  animation-name: http_to_transitional;
}

.http_to_https {
  animation-duration: 2s;
  animation-name: http_to_https;
}

@keyframes http_to_transitional {
  from {
    fill: #f88;
  }

  to {
    fill: #88f;
  }
}

@keyframes http_to_https {
  from {
    fill: #f88;
  }

  to {
    fill: #8f8;
  }
}

.hyperlink {
    fill: none;
}
.hyperlink.http {
  stroke-width: 1.5px;
  stroke: #fff;
}

.hyperlink.https {
    stroke-width: 1.5px;
    stroke: #000;
}

.hyperlink.underlay {
  fill: none;
  stroke: #000;
  stroke-width: 1.5px;
}

        </style>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
    </head>
    <body>

        <script>
                    function drawFigure(targetName, data) {
                        var targetNode = document.getElementById(targetName);
                        var jsonData = JSON.parse(document.getElementById(data).textContent);

                        jsonData.resources.forEach( function(rsc) {
                            if(!rsc.size) { rsc.size = 80; }
                            rsc.children.forEach( function(child) {
                                if(!child.size) { child.size = 15; }
                            });
                        });
                        
                        
                        var width = targetNode.getBoundingClientRect().width,
                            height = targetNode.getBoundingClientRect().height;

                        var svg = d3.select(targetNode).append("svg")
                        .attr("width", width)
                        .attr("height", height);

                        // Per-type markers, as they don't inherit styles.
                        svg.append("defs").selectAll("marker")
                            .data(["http", "https", "transitional"])
                            .enter().append("marker")
                            .attr("id", function(d) { return d; })
                            .attr("viewBox", "0 -5 10 10")
                            .attr("refX", 25)
                            .attr("refY", -1.5)
                            .attr("markerWidth", 8)
                            .attr("markerHeight", 6)
                            .attr("orient", "auto")
                            .append("path")
                            .attr("d", "M0,-5L10,0L0,5");
                        
                        var origin = svg.append("g").selectAll(".node")
                        .data(jsonData.origins)
                        .enter().append("g")
                        .attr("transform", function(d) { return "translate("+ d.x +","+ d.y +")" })
                        .attr("state", function(d) { return d.state; })
                        .attr("id", function(d) { return targetName + "_origins_"  + d.name; });

                         origin.append("circle")
                        .attr("x", 0)
                        .attr("y", 0)
                        .attr("r", 80)
                        .attr("class", function(d) { return d.state + " " + d.name; });

                        origin.append("text")
                        .style("text-anchor", "middle")
                        .text(function(d) { return (d.state == "transitional" ? "http" : d.state) + "://" + d.name; })
                        .attr("transform", "translate(0,-85)");

                        // insert these after origins, before resources, then add "d" attr later.
                        var hyperlink_underlay = svg.append("g").selectAll("path")
                        .data(jsonData.links)
                        .enter().append("path")
                        .attr("class", "hyperlink underlay");

                        var hyperlink = svg.append("g").selectAll("path")
                        .data(jsonData.links)
                        .enter().append("path")
                        .attr("id", function(d) { return targetName + "_hyperlinks_" + d.fromResource + "_to_" + d.toResource })
                        .attr("stroke-dasharray", "5,5")
                        .attr("class", function(d) { return "hyperlink " + (d.scheme ? d.scheme : "") })
                        .attr("marker-end", function(d) { return "url(#" + d.scheme + ")"; });
                        
                        var resources = jsonData.resources;
                        for(var i = 0; i < resources.length; i++) {

                            var originNode = d3.select("#" + targetName + "_origins_" + resources[i].origin).node();

                            var pack = d3.layout.pack()
                            .padding(30)
                            .size([150, 150])
                            .value(function(d) { return d.size; });

                            var g = svg.append("g")
                            .attr("transform", originNode.attributes.transform.value);

                            var pnode = g.datum(resources[i]).selectAll(".node")
                            .data(pack.nodes)
                            .enter().append("g")
                            .attr("transform", function(d) { return "translate(" + (d.x - 75) + "," + (d.y - 75) + ")"; });

                            pnode.append("circle")
                                .attr("r", function(d) { return d.size; })
                                .attr("id", function(d) { return targetName + "_resources_" + (d.id ? d.id : "packingGroup"); })
                                .attr("class", function(d) {
                                    var depthClass = d.depth > 0 ? "resource" : "packingGroup";
                                    var stateClass = d.depth == 0 ? "" :
                                        (d.state ? d.state : originNode.attributes.state.value);
                                    var originClass = d.depth == 0 ? "" : resources[i].origin;
                                    return depthClass + " " + stateClass + " " + originClass;
                                });

                            pnode.filter(function(d) { return d.depth > 0; }).append("text")
                                .attr("dy", ".3em")
                                .style("text-anchor", "middle")
                                .text(function(d) { return d.name.substring(0, d.r / 3); })
                        }

                        svg.selectAll(".hyperlink").attr("d", hyperlinkArc);

                        function hyperlinkArc(d) {
                            var target = d3.select("#" + targetName + "_resources_" + d.toResource).node();
                            var source = d3.select("#" + targetName + "_resources_" + d.fromResource).node();
                            var offset = svg.node().getBoundingClientRect();
                            var tMatrix = target.getScreenCTM();
                            var sMatrix = source.getScreenCTM();
                            
                            var sCoords = getXformedCoords(source.cx.baseVal.value, source.cy.baseVal.value, offset, sMatrix);
                            var tCoords = getXformedCoords(target.cx.baseVal.value, target.cy.baseVal.value, offset, tMatrix);

                            var dx = tCoords.x - sCoords.x,
                                dy = tCoords.y - sCoords.y,
                                dr = Math.sqrt(dx * dx + dy * dy);
                            return "M" + sCoords.x + "," + sCoords.y + "A" + dr + "," + dr + " 0 0,1 " + tCoords.x + "," + tCoords.y;
                        };
                        
                        function getXformedCoords(x, y, offset, matrix) {
                            return {
                                x: (matrix.a * x) + (matrix.c * y) + matrix.e - offset.left,
                                y: (matrix.b * x) + (matrix.d * y) + matrix.f - offset.top
                            }
                        }
                    }
        </script>

        
        <script id="figure1data" type="application/json">
        {
            "origins" : [
                {"name": "OriginA", "x": 300, "y": "100", "state": "https"},
                {"name": "OriginB", "x": 180, "y": "300", "state": "http"},
                {"name": "OriginC", "x": 400, "y": "300", "state": "transitional"},
                {"name": "OriginD", "x": 100, "y": "100", "state": "https"}
            ],
            "links": [
                {"fromResource": "1", "toResource":"2", "scheme":"https"},
                {"fromResource": "1", "toResource":"3", "scheme":"https"},
                {"fromResource": "1", "toResource":"6", "scheme":"http"},
                {"fromResource": "1", "toResource":"10", "scheme":"https"},
                {"fromResource": "7", "toResource":"6", "scheme":"http"},
                {"fromResource": "11", "toResource":"9", "scheme":"http"},
                {"fromResource": "11", "toResource":"2", "scheme":"https"}
            ],
            "resources": [
                {
                    "origin" : "OriginA",
                    "size" : 100,
                    "children" :  [
                        {"name" : "HTML", "id" : "11", "size" : 18, "state" : "https"},
                        {"name" : "HTML", "id" : "1", "size" : 18, "state" : "mixed"},
                        {"name" : "JS",   "id" : "2" },
                        {"name" : "JPG",  "id" : "3" }
                    ]
                },
                {
                    "origin" : "OriginB",
                    "children" :  [
                        {"name" : "HTML", "id" : "4", "size" : 18},
                        {"name" : "JSON", "id" : "5"},
                        {"name" : "JS",   "id" : "6"}
                    ]
                },
                {
                    "origin" : "OriginC",
                    "children" :  [
                        {"name" : "HTML", "id" : "7", "size" : 18},
                        {"name" : "JSON", "id" : "8"},
                        {"name" : "JS",   "id" : "9"}
                    ]
                },
                {
                    "origin" : "OriginD",
                    "size" : 40,
                    "children" :  [
                        {"name" : "JS", "id" : "10"}
                    ]
                }
            ]
        }
        </script>
        
        <!--
        <div id="figure1" style="height: 400px"></div>
        <script>drawFigure("figure1", "figure1data");</script>
        -->
        <h1>
            Why isn't HTTPS everywhere yet?
        </h1>
        <p>
            Encryption.  We all like it and want more of it.  Why isn't HTTPS
            everywhere yet?
        </p>
        <h2>
            Is it certificates?
        </h2>
        <p>
            The first and most commonly cited barrier to HTTPS everywhere is
            the cost (both time and effort) of
            obtaining, configuring, presenting and maintaining a valid
            certificate.  You must find a certificate authority, prove your
            identity, pay for a certificate, set it up on your server (you
            probably need to have a dedicated IPv4 address to support old 
            clients that don't
            do Server Name Indication) and renew it before it expires.
        </p>
        <p>
            A lot of the proposals for "opportunistic" encryption are targeted
            at this level of the problem, and amount to: "The NSA is
            recording all of our traffic, so why don't we just encrypt even if
            we don't have a certificate?"
        </p>
        <p>
            I appreciate the spirit of this solution, but I have come
            to believe it is actually targeting the wrong obstacles. First, this
            flavor of OE solves very few problems because you can never rely on
            it, even when it appears to succeed.  For users that care, it offers
            little comfort, and for site operators who want to get to reliable
            guarantees, it offers no easier path forward. Second, I don't think
            the certificate problem is actually the biggest challenge blocking
            HTTPS everywhere anymore.
        </p>
        <p>
            The fine folks over at
            <a href="https://letsencrypt.org/">Let's Encrypt</a>
            already realized that the
            certficate problem is mostly amenable to automation, and that
            automating the issuance, installation, configuration, deployment
            and renewal of certificates and TLS on a relatively few of the major
            servers+platforms can cover a substantial supermajority of the
            Internet.  This is amazing work, and while there is still much of
            that race left to be run, I think we can optimistcally call it a
            solved problem.
        </p>
        <p>
            The SNI + IPv4 issue (mulitple hosts can't share the same IPv4
            address for clients that don't support Server Name Indication
            without getting a certificate with all of their names in it) I am
            confident will naturally resolve itself as those old platforms
            tail off and IPv6 ramps up.
        </p>
        
        <h2>
            Now we have a certificate, we can turn on HTTPS, right?
        </h2>
        <p>
            Well, maybe.  But probably not.  If all of the HTML resources you
            serve have subresources (images, scripts, etc.) loaded from the
            same host AND you used only relative urls (e.g. "/foo.jpg" instead
            of "http://example.com/foo.jpg") then you are good to go!  Otherwise
            things are probably broken for you at your "https://" URLs.
        </p>
        <p>
            <i>Wait, what?  HTTPS is supposed to be good. Why is everything
            broken?</i>
        </p>
        <p>
            It's broken because you almost certainly have
            <a href="http://w3.org/TR/mixed-content">Mixed Content</a>
            in your pages.
        </p>
        <h2>What is Mixed Content and why should I care?</h2>
        <p>
            Mixed Content is the term that has arisen out of practice
            for the situation when a document loaded over https includes content
            loaded over http.
        </p>

        <p>
            Consider the following set of resources, where you are the operator
            of "OriginA".  Green circles represent resources avialable over
            both https and http schemes, red circles represent resources only
            available over http schemes.  Dashed lines represent subresource
            includes made with an http scheme.  Solid lines represent subresource
            includes made with an https scheme.  Assume that all links are absolute,
            not relative.
        </p>
        <script id="figure2data" type="application/json">
        {
            "origins" : [
                {"name": "OriginA", "x": 300, "y": "100", "state": "http"},
                {"name": "OriginB", "x": 200, "y": "300", "state": "http"},
                {"name": "OriginC", "x": 100, "y": "100", "state": "https"}
            ],
            "links": [
                {"fromResource": "1", "toResource":"2", "scheme":"http"},
                {"fromResource": "1", "toResource":"3", "scheme":"http"},
                {"fromResource": "1", "toResource":"6", "scheme":"http"},
                {"fromResource": "1", "toResource":"10", "scheme":"http"}
            ],
            "resources": [
                {
                    "origin" : "OriginA",
                    "size" : 100,
                    "children" :  [
                        {"name" : "HTML", "id" : "1", "size" : 18},
                        {"name" : "JS",   "id" : "2" },
                        {"name" : "JPG",  "id" : "3" }
                    ]
                },
                {
                    "origin" : "OriginB",
                    "children" :  [
                        {"name" : "HTML", "id" : "4", "size" : 18},
                        {"name" : "JSON", "id" : "5"},
                        {"name" : "JS",   "id" : "6"}
                    ]
                },
                {
                    "origin" : "OriginC",
                    "size" : 40,
                    "children" :  [
                        {"name" : "JS", "id" : "10"}
                    ]
                }
            ]
        }
        </script>
        
        <div id="figure2" style="height: 400px"></div>
        <script>drawFigure("figure2", "figure2data");</script>

        <p>
            Now let's say you acquire a certificate and turn on https for OriginA.
            What does the resource graph look like now?
        </p>
        
        <script id="figure3data" type="application/json">
        {
            "origins" : [
                {"name": "OriginA", "x": 300, "y": "100", "state": "https"},
                {"name": "OriginB", "x": 200, "y": "300", "state": "http"},
                {"name": "OriginC", "x": 100, "y": "100", "state": "https"}
            ],
            "links": [
                {"fromResource": "1", "toResource":"2", "scheme":"http"},
                {"fromResource": "1", "toResource":"3", "scheme":"http"},
                {"fromResource": "1", "toResource":"6", "scheme":"http"},
                {"fromResource": "1", "toResource":"10", "scheme":"http"}
            ],
            "resources": [
                {
                    "origin" : "OriginA",
                    "size" : 100,
                    "children" :  [
                        {"name" : "HTML", "id" : "1", "size" : 18, "state": "mixed"},
                        {"name" : "JS",   "id" : "2" },
                        {"name" : "JPG",  "id" : "3" }
                    ]
                },
                {
                    "origin" : "OriginB",
                    "children" :  [
                        {"name" : "HTML", "id" : "4", "size" : 18},
                        {"name" : "JSON", "id" : "5"},
                        {"name" : "JS",   "id" : "6"}
                    ]
                },
                {
                    "origin" : "OriginC",
                    "size" : 40,
                    "children" :  [
                        {"name" : "JS", "id" : "10"}
                    ]
                }
            ]
        }
        </script>
        
        <div id="figure3" style="height: 400px"></div>
        <script>drawFigure("figure3", "figure3data");</script>
        
        <p>
            If you haven't updated absolute links in the HTML document, it will
            still be attempting to load all of its resources with an http scheme.
            Most web browsers block such loads or give negative UI feedback when
            they occur, and they have been getting more and more strict about it
            over time.  The HTML resource at OriginA will be broken because
            attempts to load the three JS resources it depends on will be blocked,
            and it will be marked with a mixed content warning for the JPG, even
            if we didn't have the JS resources.
        </p>
        
        <h3>
            Why do browsers block mixed content loads?
            Why can't I as a site operator make that decision?
        </h3>
        <p>
            In most of the Web security model, Origins (the scheme+host+port
            tuple of a URL) are authoritative for their own information.  A
            document loaded from HTTPS can navigate the user to an insecure
            destination with sensitive data in the GET string or fragment,
            it can POST or postMessage() to insecure schemes or origins, and
            an https resource can receive GET, POST or onMessage() from documents
            loaded over http. So, if we don't have formal information flow controls
            on the Web, why is Mixed Content Blocking a thing? If I can POST,
            why can't I XHR?
        </p>
        <p>
            It turns out there is  one formal security property that
            browsers try to enforce on documents.  That is a property
            first formulated as <i>"Tranquility"</i> by 
            <a href="https://en.wikipedia.org/wiki/Bell%E2%80%93LaPadula_model">
            Bell and LaPadula in their 1973 integrity model.</a>
            In simple terms, the tranquility enforced by web browsers is that
            a secure docment will not become insecure while you are interacting
            with it.
        </p>
        <p>
            Among all the complexity and
            potential pitfalls of Web security, browsers have come to
            the conclusion that there is only one semi-reliable and usable security
            indicator: the URL bar and HTTPS lock.  If you type "https://" into
            the address bar, or at any point check to see if there is a lock
            icon for the document you are interacting with, the browser has made
            you a promise that the content is protected from threats involving a
            hostile network. (or alternately, the browser is conveying a promise
            from the site operator which it is unwilling to let it reneg on)
        </p>
        <p>
            If your https
            document were to load a script, preform a fetch or even load an image
            over http, that promise would be broken.  How broken and what the
            exact consequences would be
            might vary widely, but the browser isn't in a position to know, and
            doesn't want to impose the burden of that subtlety on the user, so
            they simply block.  This is done not only to protect users who
            wouldn't otherwise be aware that, e.g., a webmail application which
            shows https in the address bar but includes script over http isn't
            safe to use in a coffeeshop in the
            hacker part of town, but also to highlight the same issue to content
            authors who might themselves otherwise miss this subtle point.
        </p>
        <p>
            This is a good thing for users, but it puts site operators newly in
            posession of a certificate in a bit of difficulty when it comes to
            turning on https.  All of their HTML resources which reference
            insecure content are going to break outright or alarm some population
            of users, either by showing a warning or simply not showing the lock
            they expect for https.  <b>This dependency problem, I assert, is the real
            cost barrier we must surmount in order to move the rest of the Web
            to 100% HTTPS.</b>
        </p>
        <h2>
            Fixing Mixed Content
        </h2>
        <p>
            As soon as you have to fix Mixed Content, the cost
            of migrating to HTTPS starts to get real.  Much more so than any
            kind of server configuration or acquisition of a certificate, removing
            mixed content is expensive and not always well-suited to automation because it often
            requires understanding all the possible content served by a host,
            modifying it (conditionally) and (possibly most expensively) testing
            to verify that everything works.
        </p>
        <p>
            For a complex site, it's not as simple as running s/http/https/g
            across all of your resources, on disk or with a mod_rewrite rule.
            You might encounter http-schemed resources in many places: static
            content, dynamic content generated on the server, on the client,
            stored in databases (on the server or client), retrieved from other
            third party redirects, etc.
        </p>
        <p>
            A new specification under development, (and already supported by
            Chrome and Firefox)
            <a href="http://www.w3.org/TR/upgrade-insecure-requests/">Upgrade
            Insecure Requests</a>, aims to ease this burden by automatically
            upgrading http subresource fetches to https, along with same-origin
            navigations.
        </p>
        
        <script id="figure4data" type="application/json">
        {
            "origins" : [
                {"name": "OriginA", "x": 300, "y": "100", "state": "https"},
                {"name": "OriginB", "x": 200, "y": "300", "state": "http"},
                {"name": "OriginC", "x": 100, "y": "100", "state": "https"}
            ],
            "links": [
                {"fromResource": "1", "toResource":"2", "scheme":"http"},
                {"fromResource": "1", "toResource":"3", "scheme":"http"},
                {"fromResource": "1", "toResource":"6", "scheme":"http"},
                {"fromResource": "1", "toResource":"10", "scheme":"http"},
                {"fromResource": "11", "toResource":"2", "scheme":"http"},
                {"fromResource": "11", "toResource":"10", "scheme":"http"}
            ],
            "resources": [
                {
                    "origin" : "OriginA",
                    "size" : 100,
                    "children" :  [
                        {"name" : "HTML", "id" : "1", "size" : 18, "state": "mixed"},
                        {"name" : "JS",   "id" : "2" },
                        {"name" : "JPG",  "id" : "3" },
                        {"name" : "HTML", "id" : "11", "size" : 18, "state" : "mixed"}
                    ]
                },
                {
                    "origin" : "OriginB",
                    "children" :  [
                        {"name" : "HTML", "id" : "4", "size" : 18},
                        {"name" : "JSON", "id" : "5"},
                        {"name" : "JS",   "id" : "6"}
                    ]
                },
                {
                    "origin" : "OriginC",
                    "size" : 40,
                    "children" :  [
                        {"name" : "JS", "id" : "10"}
                    ]
                }
            ]
        }
        </script>

        <script id="figure5data" type="application/json">
        {
            "origins" : [
                {"name": "OriginA", "x": 300, "y": "100", "state": "https"},
                {"name": "OriginB", "x": 200, "y": "300", "state": "http"},
                {"name": "OriginC", "x": 100, "y": "100", "state": "https"}
            ],
            "links": [
                {"fromResource": "1", "toResource":"2", "scheme":"https"},
                {"fromResource": "1", "toResource":"3", "scheme":"https"},
                {"fromResource": "1", "toResource":"6", "scheme":"https"},
                {"fromResource": "1", "toResource":"10", "scheme":"https"},
                {"fromResource": "11", "toResource":"2", "scheme":"https"},
                {"fromResource": "11", "toResource":"10", "scheme":"https"}
            ],
            "resources": [
                {
                    "origin" : "OriginA",
                    "size" : 100,
                    "children" :  [
                        {"name" : "HTML", "id" : "1", "size" : 18, "state": "mixed"},
                        {"name" : "JS",   "id" : "2" },
                        {"name" : "JPG",  "id" : "3" },
                        {"name" : "HTML", "id" : "11", "size" : 18}
                    ]
                },
                {
                    "origin" : "OriginB",
                    "children" :  [
                        {"name" : "HTML", "id" : "4", "size" : 18},
                        {"name" : "JSON", "id" : "5"},
                        {"name" : "JS",   "id" : "6"}
                    ]
                },
                {
                    "origin" : "OriginC",
                    "size" : 40,
                    "children" :  [
                        {"name" : "JS", "id" : "10"}
                    ]
                }
            ]
        }
        </script>
        
        <h3>Before</h3>
        <div id="figure4" style="height: 400px; width: 500px"></div>
        
        <h3>After Upgrade-Insecure-Requests</h3>
        <div id="figure5" style="height: 400px; width: 500px"></div>
        <script>drawFigure("figure4", "figure4data");</script>
        <script>drawFigure("figure5", "figure5data");</script>
        
        
        <p>
            Upgrade-Insecure-Resources has helped OriginA here.
            One of its HTML resources is now
            free of mixed content because all of the link schemes have been transparently
            upgraded and all its remote dependencies are available over https.
            However, we still have one broken resource because the JS dependency
            from OriginB is still not available over https.
            This illustrates why, until all of their dependencies have upgraded
            to https, many sites are reluctant to offer any of their own content
            over https, to avoid presenting users with broken experiences and
            worrying error messages.
        </p>
        <p>
            This leads to the unfortunate circumstance that the least
            accountable actors at the end of long dependency chains can hold
            back progress for everyone upstream. Cyclical dependencies
            (as certainly exist in the large scale structure of the web) can
            create deadlocks which totally prevent upgrades without coordination.
        </p>
        <h3>None of these sites can turn on https</h3>
        <script id="figure6data" type="application/json">
        {
            "origins" : [
                {"name": "OriginA", "x": 300, "y": "300", "state": "http"},
                {"name": "OriginB", "x": 200, "y": "100", "state": "http"},
                {"name": "OriginC", "x": 100, "y": "300", "state": "http"}
            ],
            "links": [
                {"fromResource": "1", "toResource":"4", "scheme":"http"},
                {"fromResource": "3", "toResource":"6", "scheme":"http"},
                {"fromResource": "5", "toResource":"2", "scheme":"http"}
            ],
            "resources": [
                {
                    "origin" : "OriginA",
                    "children" :  [
                        {"name" : "HTML", "id" : "1", "size" : 18},
                        {"name" : "JS",   "id" : "2" }
                    ]
                },
                {
                    "origin" : "OriginB",
                    "children" :  [
                        {"name" : "HTML", "id" : "3", "size" : 18},
                        {"name" : " JS",   "id" : "4" }
                    ]
                },
                {
                    "origin" : "OriginC",
                     "children" :  [
                        {"name" : "HTML", "id" : "5", "size" : 18},
                        {"name" : "JS",   "id" : "6" }
                    ]
                }
            ]
        }
        </script>
        
        <div id="figure6" style="height: 400px"></div>
        <script>drawFigure("figure6", "figure6data");</script>
        <p>
            To make matters even worse, it is not trivial to even determine if
            your dependencies are ready!  Once you go HTTPS, errors will
            just start happening for your users, and you have no obvious way to
            catch them in advance. (A "<tt>default-src https:</tt>" Content Security
            Policy directive can tell you when things actually broke, but you
            can't easily compose it with an optimistic upgrade to test without
            actual breakage.)
        </p>
        <p>For modern applications with complex client-side logic,
            serving large user bases, and using things like Real-Time-Bidding
            advertising networks, the difficulty of creating a reasonable simulation of
            traffic and user experience for test purposes is quite real. Just
            the set of domain names you reference may be emergent runtime
            behavior with substantial variance over time.
        </p>
        <h2>
            Breaking the deadlock
        </h2>
        <p>
            What we lack is an intermediate state between http and https.
            Ideally, such a state would have the following properties:
            <ol>
                <li>
                    Allow secure origins which depend on resources you serve to
                    retrieve them in way which does not violate their secure
                    tranquility.
                </li>
                <li>
                    Do not force resources to make premature or unverified
                    guarantees of secure tranquility / lack of mixed content.
                </li>
                <li>
                    Be extremely low-cost and low-risk to deploy; ideally
                    requiring zero content-level changes, only server
                    configuration updates. (including possibly adding one or
                    more http headers)
                </li>
                <li>
                    Allow detection of dependencies which would violate secure
                    tranquility / produce mixed content errors without
                    negatively impacting the user experience.
                </li>
            </ol>
        </p>
            <script id="figure7data" type="application/json">
        {
            "origins" : [
                {"name": "OriginA", "x": 300, "y": "300", "state": "http"},
                {"name": "OriginB", "x": 200, "y": "100", "state": "http"},
                {"name": "OriginC", "x": 100, "y": "300", "state": "http"},
                {"name": "OriginD", "x": 400, "y": "100", "state": "http"}
            ],
            "links": [
                {"fromResource": "1", "toResource":"4", "scheme":"http"},
                {"fromResource": "3", "toResource":"6", "scheme":"http"},
                {"fromResource": "3", "toResource":"7", "scheme":"http"},
                {"fromResource": "5", "toResource":"2", "scheme":"http"}
            ],
            "resources": [
                {
                    "origin" : "OriginA",
                    "children" :  [
                        {"name" : "HTML", "id" : "1", "size" : 18},
                        {"name" : "JS",   "id" : "2" }
                    ]
                },
                {
                    "origin" : "OriginB",
                    "children" :  [
                        {"name" : "HTML", "id" : "3", "size" : 18},
                        {"name" : " JS",   "id" : "4" }
                    ]
                },
                {
                    "origin" : "OriginC",
                     "children" :  [
                        {"name" : "HTML", "id" : "5", "size" : 18},
                        {"name" : "JS",   "id" : "6" }
                    ]
                },
                {
                    "origin" : "OriginD",
                     "children" :  [
                        {"name" : "JS",   "id" : "7" }
                    ]
                }
            ]
        }
        </script>
        
        <h3>Click on the figure below to see how introducing an intermediate
            state (indicated with blue) with these properties can break an upgrade deadlock cycle.</h3>

        <div id="figure7" style="height: 400px" onclick="animateFigure7()"></div>
        <script>
            function h2h2t(d) {
                return d.replace(/\bhttp\b/, "http_to_transitional");
            }
            
            function h2t2t(d) {
                return d.replace(/\bhttp_to_transitional\b/, "transitional ");
            }
            
            function h2h2s(d) {
                return d.replace(/http /, "http_to_https ");
            }
            
            function h2s2s(d) {
                return d.replace(/http_to_https /, "https ");
            }
            
            function h2s(d) {
                return d.replace(/http/, "https");
            }
            
            function animateFigure7() {
            document.getElementById("figure7_origins_OriginB")
            .firstChild
            .addEventListener("animationend", step1, false);
            
            // step 0
            document.getElementById("figure7_origins_OriginB")
                .lastChild
                .textContent = "http[s]://OriginB";
                
            d3.selectAll("#figure7 circle.OriginB")
                .attr("class", function(d) { return h2h2t(d3.select(this).attr("class")) });
            
            function step1() {
                d3.selectAll("#figure7 circle.OriginB")
                .attr("class", function(d) { return h2t2t(d3.select(this).attr("class")) });
                
                document.getElementById("figure7_origins_OriginA")
                .firstChild
                .addEventListener("animationend", step2, false);
                
                document.getElementById("figure7_origins_OriginA")
                .lastChild
                .textContent = "https://OriginA";
                
                d3.selectAll("#figure7 circle.OriginA")
                .attr("class", function(d) { return h2h2s(d3.select(this).attr("class")) });
            }
            
            function step2() {
                d3.selectAll("#figure7 circle.OriginA")
                .attr("class", function(d) { return h2s2s(d3.select(this).attr("class")) });
                
                document.getElementById("figure7_origins_OriginC")
                .firstChild
                .addEventListener("animationend", step3, false);
                
                document.getElementById("figure7_origins_OriginC")
                .lastChild
                .textContent = "https://OriginC";
                
                d3.selectAll("#figure7 circle.OriginC")
                .attr("class", function(d) { return h2h2s(d3.select(this).attr("class")) });
                
                d3.select("#figure7_hyperlinks_5_to_2")
                .attr("class", function(d) { return h2s(d3.select(this).attr("class")) });
            }
            
            function step3() {
                d3.selectAll("#figure7 circle.OriginC")
                .attr("class", function(d) { return h2s2s(d3.select(this).attr("class")) });
                // TODO reset figure?
            }
                
            }
            
            drawFigure("figure7", "figure7data");

        </script>

        <p>
            First, OriginB turns on "https transitional" mode.  This means that is resources are
            still not available at URLs with an https scheme, but are optimistically available
            over TLS with the full guarantees, including a valid certificate.  This is essentially
            zero-cost for OriginB because it makes no new guarantees to users or browsers about
            the security state or tranquility of its own resources.
        </p>
        <p>
            Now that OriginB's resources are available via "https transitional", OriginA turns on
            https.  It has an HTML file with an http dependency on the JS file at OriginB.  A
            browser that knows about "https transitional" can try to initiate a TLS connection
            to OriginB and ask for the resource with its original http scheme.  If this
            optimistic upgrade fails, it would be treated as insecure and trigger mixed content
            blocking, so we haven't reduced the guarantees to users of OriginA.  If it succeeds,
            all of the standard guarantees required for OriginA to be secure and tranquil are met,
            and no mixed content warning or blocking would be triggered, even though the reference
            to the JS file at OriginB still used the http scheme.
        </p>
        <p>
            Now that OriginA has upgraded, OriginC can upgrade, too.  OriginB still has a dependency
            to OriginD which is only  http, so it can't yet go to https, but by turning on
            transitional mode, it has unblocked upgrades for A and B, without creating any negative
            user experiences for its own users due to mixed content from D.  Without the transitional
            state, none of these sites could have upgraded.
        </p>
    
        <p>
            The interesting bit here is the link from OriginA's HTML resource to OriginB's JS resource.
            It needs to satisfy all the properties of TLS - but whether it remains an http scheme that
            is transparently upgraded during the fetch from OriginB, or whether it is upgraded at OriginA
            before a fetch is even attempted depends on how this transitional state might be implemented.
        </p>
    
        <h2>
            How could we introduce this state?
        </h2>
        <p>
            A first approxmiation, just to break resource dependency deadlocks without introducing documents
            with mixed content into the world, would be to enable https
            with a server filter that returns a 404 whenever it would otherwise return a Content-Type of text/html.
            In fact, it's probably a surprisingly good approximation, modulo some edge cases involving
            CORS. Of the four properties we are interested in, this even gets us a pretty good take on three of them.
        <p>
            What is missing is the 4th property - the ability to detect the state of your own dependencies so
            you can know when it's OK to flip the "real https" switch.  What if browsers could do
            Content-Security-Policy-Report-Only with "upgrade-insecure-requests" for http documents?
            <ol>
                <li>attempt to upgrade</li>
                <li>if upgrade fails</li>
                <ol>
                    <li>fall back to http fetch</li>
                    <li>fire a report</li>
                </ol>
            </ol>
            This would introduce considerable latency for http pages employing
            it, as many of the upgrades would fail and they would have to block on those failures before retrying
            with http.  Perhaps HTTP/2 Alternative Services could be employed, and the upgrade would only be
            attempted if an https AltSvc was advertised?
        </p>
        <p>
            Is it possible we don't need anything more than that?  Basically this
            configuration, with Upgrade-Insecure-Requests
            implied for A, B, and C?
        </p>
            <script id="figure8data" type="application/json">
        {
            "origins" : [
                {"name": "OriginA", "x": 300, "y": "300", "state": "https"},
                {"name": "OriginB", "x": 200, "y": "100", "state": "https"},
                {"name": "OriginC", "x": 100, "y": "300", "state": "https"},
                {"name": "OriginD", "x": 400, "y": "100", "state": "http"}
            ],
            "links": [
                {"fromResource": "1", "toResource":"4", "scheme":"https"},
                {"fromResource": "3", "toResource":"6", "scheme":"http"},
                {"fromResource": "3", "toResource":"7", "scheme":"http"},
                {"fromResource": "5", "toResource":"2", "scheme":"https"}
            ],
            "resources": [
                {
                    "origin" : "OriginA",
                    "children" :  [
                        {"name" : "HTML", "id" : "1", "size" : 18},
                        {"name" : "JS",   "id" : "2" }
                    ]
                },
                {
                    "origin" : "OriginB",
                    "children" :  [
                        {"name" : "HTML", "id" : "3", "size" : 18, "state" : "http"},
                        {"name" : " JS",   "id" : "4", "state" : "https"}
                    ]
                },
                {
                    "origin" : "OriginC",
                     "children" :  [
                        {"name" : "HTML", "id" : "5", "size" : 18},
                        {"name" : "JS",   "id" : "6" }
                    ]
                },
                {
                    "origin" : "OriginD",
                     "children" :  [
                        {"name" : "JS",   "id" : "7" }
                    ]
                }
            ]
        }
        </script>
        
        <div id="figure8" style="height: 400px"></div>
        <script>drawFigure("figure8", "figure8data");</script>

        <h3>Enter the &lt;iframe&gt;</h3>
        <p>
            One of the problems with simply not offering HTML resources over
            https is when there are HTML to HTML dependencies in the form of
            iframes.  This is actually quite common for advertising.
        </p>

        <script id="figure9data" type="application/json">
        {
            "origins" : [
                {"name": "OriginA", "x": 100, "y": "100", "state": "https"},
                {"name": "OriginB", "x": 300, "y": "100", "state": "https"}
            ],
            "links": [
                {"fromResource": "1", "toResource":"4", "scheme":"https"},
                {"fromResource": "1", "toResource":"3", "scheme":"http"},
                {"fromResource": "1", "toResource":"2", "scheme":"https"},
                {"fromResource": "1", "toResource":"5", "scheme":"https"}
            ],
            "resources": [
                {
                    "origin" : "OriginA",
                    "children" :  [
                        {"name" : "HTML", "id" : "1", "size" : 18},
                        {"name" : "JS",   "id" : "2" }
                    ]
                },
                {
                    "origin" : "OriginB",
                    "children" :  [
                        {"name" : "HTML", "id" : "3", "size" : 18, "state" : "http"},
                        {"name" : " JPG",   "id" : "4", "state" : "https"},
                        {"name" : " JS",   "id" : "5", "state" : "https"}
                    ]
                }
            ]
        }
        </script>
        
        <div id="figure9" style="height: 200px"></div>
        <script>drawFigure("figure9", "figure9data");</script>
        <p>
            What we need to unblock a dependency tree for iframes is also
            <i>optimistic secure tranquility</i>.  That is, we must be able to attempt
            to optimistically load an HTML resource with a TLS upgrade, and
            enforce tranquility on it, <i>but only from a secure, framed context</i>.
            The key to why this is OK is that a non-upgraded document would already be broken
            when loaded in this way, so we aren't introducing any new breakage
            or mixed content experiences for users of OriginB.
        </p>
    </body>
</html>
